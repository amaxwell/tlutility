#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This software is under a BSD license.  See LICENSE.txt for details.

import numpy as np

def _max_bounding_box(a, b):
    (xmin_a, xmax_a, ymin_a, ymax_a) = a
    (xmin_b, xmax_b, ymin_b, ymax_b) = b
    return (np.nanmin((xmin_a, xmin_b)), np.nanmax((xmax_a, xmax_b)), np.nanmin((ymin_a, ymin_b)), np.nanmax((ymax_a, ymax_b)))
    
def _bounding_box(xvalues, yvalues):        
    assert len(xvalues) == len(yvalues), "inconsistent lengths"
    if len(xvalues) == 0:
        return (0, 0, 0, 0)
    return (np.nanmin(xvalues), np.nanmax(xvalues), np.nanmin(yvalues), np.nanmax(yvalues))

class DTPath2D(object):
    """2D Path object."""
    
    def __init__(self, xvalues, yvalues, points_only=True):
        super(DTPath2D, self).__init__()
        """Create a new 2D Path.
        
        Arguments:
        xvalues -- array of x values
        yvalues -- array of y values
        points_only -- boolean indicating whether shape information is included
        
        Discussion:
        If points_only is set to False, xvalues and yvalues are assumed to have the
        correct packed array format for a DTPath2D, including all subpaths.  Otherwise,
        they are assumed to define points of a single path, and the necessary subpath
        metadata is computed.  In general, you would only pass False if reading a path
        from a file generated by DataTank.
        
        In DTSource, the array has one of two formats:
            2xN with a packed loop format.
            4xN that saves every line segment.
        In datatank_py, only the former is supported.  It's more efficient, and more
        compatible with DTSource manipulation.
        
        Layout is
        [ 0 x1 .... xN 0 x1 ... xM ...]
        [ N y1 .... yN M y1 ... yM ...]
        This allows multiple loops to be saved in a single array.
        
        DTPath2D allows iteration over subpaths (called "loops" in DTSource),
        for easier manipulation and serialization of individual paths.
        
        """
        
        assert xvalues != None and yvalues != None, "both x and y arrays are required"
        assert len(xvalues) == len(yvalues), "inconsistent lengths"   
        assert len(xvalues) > 0, "empty arrays are not allowed"
        
        xvalues = np.array(xvalues).astype(np.double)
        yvalues = np.array(yvalues).astype(np.double)
        self._bounding_box = _bounding_box(xvalues, yvalues)
        
        if points_only:
            xvalues = np.insert(xvalues, 0, 0)
            yvalues = np.insert(yvalues, 0, len(yvalues))
            
        self._xvalues = xvalues
        self._yvalues = yvalues
            
    def bounding_box(self):
        return self._bounding_box
    
    def add_loop(self, xvalues, yvalues):
        assert len(xvalues) == len(yvalues), "inconsistent lengths"
        xvalues = np.array(xvalues).astype(np.double)
        yvalues = np.array(yvalues).astype(np.double)
        if len(xvalues) > 0:
            self._bounding_box = _max_bounding_box(self._bounding_box, _bounding_box(xvalues, yvalues))
            xvalues = np.insert(xvalues, 0, 0)
            yvalues = np.insert(yvalues, 0, len(yvalues))
            self._xvalues = np.append(self._xvalues, xvalues)
            self._yvalues = np.append(self._yvalues, yvalues)
            
    def sparsified_path(self, step):
        """Sparsifies by index; no smoothing or distance considerations
        
        Sparsifies a new path by taking every N-th point, where N = step.
        Does not modify the original path object.  If a closed path was
        passed in, the returned path is also closed.  Raises an exception
        if sparsifying any subpath would result in fewer than 2 points.
        
        """
        
        sparse_path = None
        # may be a double, if coming from DTDataFile
        step = int(step)
        
        for subpath in self:
            
            # only 1 deep, so these have no subpaths
            xvals = subpath._xvalues[1:]
            yvals = subpath._yvalues[1:]
            
            indices = np.arange(0, len(xvals), step)
            xvals = xvals[indices]
            yvals = yvals[indices]            
            
            assert len(xvals) > 1, "A valid path requires at least two points."
            
            def _is_subpath_closed(path):
                first_x, first_y = path._xvalues[1], path._yvalues[1]
                last_x, last_y = path._xvalues[-1], path._yvalues[-1]
                return first_x == last_x and first_y == last_y
                
            # manipulates the new path in-place
            def _close_subpath(path):
                if _is_subpath_closed(path) == False:
                    first_x, first_y = path._xvalues[1], path._yvalues[1]
                    path._xvalues = np.append(path._xvalues, (first_x,))
                    path._yvalues = np.append(path._yvalues, (first_y,))
                    path._yvalues[0] += 1
            
            if sparse_path == None:
                sparse_path = DTPath2D(xvals, yvals)
                if _is_subpath_closed(subpath):
                    _close_subpath(sparse_path)
            else:
                sparse_path.add_loop(xvals, yvals)
                
        return sparse_path
    
    def _offsets(self):
        """List of starting index and length of each subpath element"""        
        
        offsets = []
        # (start, length)
        offset = (1, self._yvalues[0])
        offsets.append(offset)
        next = offset[0] + offset[1]
        
        while (next + 1) < len(self._yvalues):
            # next is index of the length; start is the index after that
            offset = (next + 1, self._yvalues[next])
            offsets.append(offset)
            next += offset[1] + len(offsets)            
                
        return offsets
        
    def __iter__(self):
        """Iterate subpaths in order of addition as DTPath2D objects"""
        
        for offset in self._offsets():
            start, length = offset
            yield (DTPath2D(self._xvalues[start:start + length], self._yvalues[start:start + length]))
        
    def __str__(self):
        s = super(DTPath2D, self).__str__() + " {\n"
        for idx, subpath in enumerate(self):
            s += "\n  Subpath %d (%d elements)\n" % (idx, len(subpath._xvalues - 1))
            for x, y in zip(subpath._xvalues[1:], subpath._yvalues[1:]):
                s += "    (%s, %s)\n" % (x, y)
        s += "}\n"
        return s
    
    def __dt_type__(self):
        return "2D Path"
        
    def __dt_write__(self, datafile, name):
        datafile.write_anonymous(self.bounding_box(), name + "_bbox2D")
        datafile.write_anonymous(np.dstack((self._xvalues, self._yvalues)), name)

if __name__ == '__main__':
    
    from datatank_py.DTDataFile import DTDataFile
    
    with DTDataFile("path_2d.dtbin", truncate=True) as df:
        
        xvalues = (1, 2, 2, 1, 1)
        yvalues = (1, 1, 2, 2, 1)

        df["Path 1"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.array(xvalues) * 2
        yvalues = np.array(yvalues) * 2
        df["Path 2"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.linspace(0, 10, num=100)
        yvalues = np.sin(xvalues)
        xvalues = np.append(xvalues, np.flipud(xvalues))
        xvalues = np.append(xvalues, xvalues[0])
        yvalues = np.append(yvalues, -yvalues)
        yvalues = np.append(yvalues, yvalues[0])
        df["Path 3"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.array((-1, -1, 1, 1, -1))
        yvalues = np.array((-1, 1, 1, -1, -1))
        path = DTPath2D(xvalues, yvalues)
        xvalues = xvalues * 0.5
        yvalues = yvalues * 0.5
        path.add_loop(xvalues, yvalues)
        df["Path 4"] = path
        
        for idx, subpath in enumerate(path):
            df["Subpath %d" % (idx)] = path
        
        
