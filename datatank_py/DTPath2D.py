#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This software is under a BSD license.  See LICENSE.txt for details.

import numpy as np

def _max_bounding_box(a, b):
    (xmin_a, xmax_a, ymin_a, ymax_a) = a
    (xmin_b, xmax_b, ymin_b, ymax_b) = b
    return (np.nanmin((xmin_a, xmin_b)), np.nanmax((xmax_a, xmax_b)), np.nanmin((ymin_a, ymin_b)), np.nanmax((ymax_a, ymax_b)))
    
def _bounding_box(xvalues, yvalues):        
    assert len(xvalues) == len(yvalues), "DTPath2D: inconsistent lengths for bbox"
    if len(xvalues) == 0:
        return (0, 0, 0, 0)
    return (np.nanmin(xvalues), np.nanmax(xvalues), np.nanmin(yvalues), np.nanmax(yvalues))

class DTPath2D(object):
    """2D Path object."""
    
    def __init__(self, xvalues, yvalues, points_only=True):
        super(DTPath2D, self).__init__()
        """Create a new 2D Path.
        
        Arguments:
        xvalues -- array of x values
        yvalues -- array of y values
        points_only -- boolean indicating whether shape information is included
        
        Discussion:
        The input arrays must have the same length.
        
        If points_only is set to False, xvalues and yvalues are assumed to have the
        correct packed array format for a DTPath2D, including all subpaths.  Otherwise,
        they are assumed to define points of a single path, and the necessary subpath
        metadata is computed.  In general, you would only pass False if reading a path
        from a file generated by DataTank.
        
        In DTSource, the array has one of two formats:
            2xN with a packed loop format.
            4xN that saves every line segment.
        In datatank_py, only the former is supported.  It's more efficient, and more
        compatible with DTSource manipulation.
        
        Layout is
          DTPath2D._xvalues = [ 0 x1 .... xN 0 x1 ... xM ...]
          DTPath2D._yvalues = [ N y1 .... yN M y1 ... yM ...]
        This allows multiple loops to be saved in a single array.
        
        DTPath2D allows iteration over subpaths (called "loops" in DTSource),
        for easier manipulation and serialization of individual paths.
        
        """
        
        assert xvalues != None and yvalues != None, "DTPath2D: both x and y arrays are required"
        assert len(xvalues) == len(yvalues), "DTPath2D: inconsistent lengths"   
        
        xvalues = np.array(xvalues).astype(np.double)
        yvalues = np.array(yvalues).astype(np.double)
        self._bounding_box = _bounding_box(xvalues, yvalues)
        
        if points_only and len(xvalues):
            xvalues = np.insert(xvalues, 0, 0)
            yvalues = np.insert(yvalues, 0, len(yvalues))
            
        self._xvalues = xvalues
        self._yvalues = yvalues
            
    def bounding_box(self):
        return self._bounding_box
    
    def add_loop(self, xvalues, yvalues):
        assert len(xvalues) == len(yvalues), "DTPath2D: inconsistent lengths"
        xvalues = np.array(xvalues).astype(np.double)
        yvalues = np.array(yvalues).astype(np.double)
        if len(xvalues) > 0:
            self._bounding_box = _max_bounding_box(self._bounding_box, _bounding_box(xvalues, yvalues))
            xvalues = np.insert(xvalues, 0, 0)
            yvalues = np.insert(yvalues, 0, len(yvalues))
            self._xvalues = np.append(self._xvalues, xvalues)
            self._yvalues = np.append(self._yvalues, yvalues)
    
    def number_of_loops(self):
        """Number of subpaths (loops) in this path."""
        return len(self._offsets())
        
    def point_list(self):
        """Returns a list of DTPoint2D objects.
        
        Raises an exception if this path has subpaths, so iterate
        if you have multiple loops.
        
        """
        
        from DTPoint2D import DTPoint2D
        assert self.number_of_loops() == 1, "Point access is only available for single-loop paths"
        return [DTPoint2D(x, y) for x, y in zip(self._xvalues[1:], self._yvalues[1:])]
            
    def sparsified_path(self, step):
        """Sparsifies by index; no smoothing or distance considerations
        
        Sparsifies a new path by taking every N-th point, where N = step.
        Does not modify the original path object.  If a closed path was
        passed in, the returned path is also closed.  Raises an exception
        if sparsifying any subpath would result in fewer than 2 points.
        
        """
        
        sparse_path = None
        # may be a double, if coming from DTDataFile
        step = int(step)
        
        for subpath in self:
            
            # only 1 deep, so these have no subpaths
            xvals = subpath._xvalues[1:]
            yvals = subpath._yvalues[1:]
            
            indices = np.arange(0, len(xvals), step)
            xvals = xvals[indices]
            yvals = yvals[indices]            
            
            # DTSource doesn't appear to impose this, but DataTank does
            assert len(xvals) > 1, "DTPath2D: A valid path requires at least two points."
            
            def _is_subpath_closed(path):
                
                # can't close an empty path or a single point
                if len(xvals) < 2:
                    return False
                    
                first_x, first_y = path._xvalues[1], path._yvalues[1]
                last_x, last_y = path._xvalues[-1], path._yvalues[-1]
                return first_x == last_x and first_y == last_y
                
            # manipulates the new path in-place
            def _close_subpath(path):
                # don't close a path that is already closed
                if not _is_subpath_closed(path):
                    first_x, first_y = path._xvalues[1], path._yvalues[1]
                    path._xvalues = np.append(path._xvalues, (first_x,))
                    path._yvalues = np.append(path._yvalues, (first_y,))
                    # update length metadata for this subpath!
                    path._yvalues[0] += 1
            
            if sparse_path == None:
                sparse_path = DTPath2D(xvals, yvals)
                if _is_subpath_closed(subpath):
                    _close_subpath(sparse_path)
            else:
                sparse_path.add_loop(xvals, yvals)
                
        return sparse_path
    
    def _offsets(self):
        """List of starting index and length of each subpath element"""        
        
        offsets = []
        # (start, length)
        offset = (1, self._yvalues[0])
        offsets.append(offset)
        next = offset[1] + 1
        
        while (next + 1) < len(self._yvalues):
            # next is index of the length; start is the index after that
            assert self._yvalues[next] > 0, "DTPath2D: negative index in offset computation"
            offset = (next + 1, self._yvalues[next])
            offsets.append(offset)
            next += offset[1] + 1
                            
        return offsets
        
    def __iter__(self):
        """Iterate subpaths in order of addition as DTPath2D objects"""
        
        for offset in self._offsets():
            start, length = offset
            yield (DTPath2D(self._xvalues[start:start + length], self._yvalues[start:start + length]))
        
    def __str__(self):
        s = super(DTPath2D, self).__str__() + " {\n"
        for idx, subpath in enumerate(self):
            s += "\n  Subpath %d (%d elements)\n" % (idx, len(subpath._xvalues) - 1)
            for x, y in zip(subpath._xvalues[1:], subpath._yvalues[1:]):
                s += "    (%s, %s)\n" % (x, y)
        s += "}\n"
        return s
    
    def __len__(self):
        total_length = 0
        for p in self:
            total_length += (len(p._xvalues) - 1)
        return total_length

    def __dt_type__(self):
        return "2D Path"
        
    def __dt_write__(self, datafile, name):
        datafile.write_anonymous(self.bounding_box(), name + "_bbox2D")
        datafile.write_anonymous(np.dstack((self._xvalues, self._yvalues)), name)
        
    @classmethod
    def from_data_file(self, datafile, name):
        
        packed_values = datafile[name]
        # no bbox in test file saved from DataTank
        bbox = datafile[name + "_bbox2D"]
        xvalues = packed_values[:,0]
        yvalues = packed_values[:,1]
        path = DTPath2D(xvalues, yvalues, points_only=False)
        if bbox != None:
            path._bounding_box = bbox
            
        return path

if __name__ == '__main__':
    
    from datatank_py.DTDataFile import DTDataFile
    
    with DTDataFile("/tmp/point_path.dtbin", truncate=True) as df:
        
        df["Path 1"] = DTPath2D([0], [0])
        
    
    with DTDataFile("path_2d.dtbin", truncate=True) as df:
        
        xvalues = (1, 2, 2, 1, 1)
        yvalues = (1, 1, 2, 2, 1)

        df["Path 1"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.array(xvalues) * 2
        yvalues = np.array(yvalues) * 2
        df["Path 2"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.linspace(0, 10, num=100)
        yvalues = np.sin(xvalues)
        xvalues = np.append(xvalues, np.flipud(xvalues))
        xvalues = np.append(xvalues, xvalues[0])
        yvalues = np.append(yvalues, -yvalues)
        yvalues = np.append(yvalues, yvalues[0])
        df["Path 3"] = DTPath2D(xvalues, yvalues)
        
        xvalues = np.array((-1, -1, 1, 1, -1))
        yvalues = np.array((-1, 1, 1, -1, -1))
        path = DTPath2D(xvalues, yvalues)
        xvalues = xvalues * 0.5
        yvalues = yvalues * 0.5
        path.add_loop(xvalues, yvalues)
        df["Path 4"] = path
        
        for idx, subpath in enumerate(path):
            df["Subpath %d" % (idx)] = path
        
        
